#include <stdio.h>
#include <math.h>

int main() {
    char r;
    double G, F, Y, a, x1, x2, b, sh, y1, y2, adapt;
    double pr = 1;
    const double pi = 3.14;
    int iter;
    nachalo:
    iter = 0;

    /* printf("Включить адаптивный шаг? 1 если да, 0 если нет \n");
     scanf ("%lf", &adapt);*/
    adapt = 1;
    /* printf("Введите x1: \n"); */
    /*scanf ("%lf", &x1);*/

    x1 = 0;
    /*printf("Введите x2: \n");*/
    /* scanf ("%lf", &x2);*/
    x2 = 10;

    /* printf("Введите kolichestvo shagov:  \n");*/
    /*scanf("%lf", &b);*/
    b = 7;


    sh = (x2 - x1) / (b - 1); /*vichislyem shag*/

    /*printf("Введите a: \n");
    scanf ("%lf", &a);*/
    a = 1;


    /* printf("Введите букву выражения, которое xотите вычислить - G,F,Y) \n");
    scanf ("%s", &r); */
    r = 'G';

    switch (r) {
        case 'G':
            while (x1 <= x2) {
                if ((45 * (pow(a, 2)) - 29 * a * x1 + 4 * (pow(x1, 2))) != 0)
                    G = -(16 * ((pow(a, 2) + 24 * a * x1 - 27 * (pow(x1, 2))))) /
                        (45 * (pow(a, 2)) - 29 * a * x1 + 4 * (pow(x1, 2)));
                if (adapt == 1) {
                    if (iter == 0) {
                        y1 = G; /*присваиваем y значение функции, находим только 1 раз */
                        printf("1 X=%.3lf Y=%.3lf\n", x1, G);
                        x1 += sh;
                    }
                    if (iter > 0) {
                        y2 = G; /*присваиваем 2 и последующие значения функции к y2 */
                        printf("2 X=%.3lf Y=%.3lf\n", x1, G);
                    }
                    if (iter > 0) { /* адаптивный шаг считается если известны оба значения*/
                        if (((y1 / y2) > 2) || ((y2 / y1) >
                                                2)) { /* если коэфициент отношения между значениями слишком большой, то уменьшаем шаг*/
                            x1 += sh / 2;
                        } else {
                            if (((y1 / y2) < 0.5) || ((y2 / y1) <
                                                      0.5)) { /*если коэфициент отношения между значениями слишком маленький, то увеличиваем шаг */
                                x1 += sh * 2;
                                y1 = y2; /*делаем "сдвиг" значений, т.е. первому значению присваевается второе*/
                            } else x1 += sh; /*если изменять шаг не нужно, то прссто прибавляем к значению Х1 размер обычного шага*/
                            if (iter > 1) {
                                y1 = y2;/*делаем "сдвиг" значений, т.е. первому значению присваевается второе*/
                            }
                        }
                    }

                } else {
                    printf("X=%.3lf Y=%.3lf\n", x1, G);
                    x1 += sh;
                }  /*если адаптивный не срабатывает, т.е. не зачем увеличивать или уменьшать шаг, то просто прибавляем значение r */
                iter += 1;
                printf("Количество шагов:%i\n", iter);
                continue;

            }
            break;

        case 'F':
            while (x1 <= x2) {
                F = -(atan(pi * (10 * (a * a) + 13 * a * x1 - 30 * (x1 * x1))));
                if (adapt == 1) {
                    if (iter == 0) {
                        y1 = F; /*присваиваем y значение функции, находим только 1 раз */
                        printf("1 X=%.3lf Y=%.3lf\n", x1, F);
                        x1 += sh;
                    }
                    if (iter > 0) {
                        y2 = F; /*присваиваем 2 и последующие значения функции к y2 */
                        printf("2 X=%.3lf Y=%.3lf\n", x1, F);
                    }
                    if (iter > 0) { /* адаптивный шаг считается если известны оба значения*/
                        if (((y1 / y2) > 2) || ((y2 / y1) >
                                                2)) { /* если коэфициент отношения между значениями слишком большой, то уменьшаем шаг*/
                            x1 += sh / 2;
                        } else {
                            if (((y1 / y2) < 0.5) || ((y2 / y1) <
                                                      0.5)) { /*если коэфициент отношения между значениями слишком маленький, то увеличиваем шаг */
                                x1 += sh * 2;
                                y1 = y2; /*делаем "сдвиг" значений, т.е. первому значению присваевается второе*/
                            } else x1 += sh; /*если изменять шаг не нужно, то прссто прибавляем к значению Х1 размер обычного шага*/
                            if (iter > 1) {
                                y1 = y2;/*делаем "сдвиг" значений, т.е. первому значению присваевается второе*/
                            }
                        }
                    }

                } else {
                    printf("X=%.3lf Y=%.3lf\n", x1, F);
                    x1 += sh;
                } /* если адаптивный не срабатывает, т.е. не зачем увеличивать или уменьшать шаг, то просто прибавляем значение r*/
                iter += 1;
                /*printf("Количество шагов:%i\n", iter);*/
                continue;
            }
            break;

        case 'Y':
            while (x1 <= x2) {
                Y = (log(2 * pow(a, 2) + 19 * a * x1 + 9 * pow(x1, 2) + 1)) / log(10);
                if (adapt == 1) {
                    if (iter == 0) {
                        y1 = Y; /*присваиваем y значение функции, находим только 1 раз */
                        printf("1 X=%.3lf Y=%.3lf\n", x1, Y);
                        x1 += sh;
                    }
                    if (iter > 0) {
                        y2 = Y; /*присваиваем 2 и последующие значения функции к y2 */
                        printf("2 X=%.3lf Y=%.3lf\n", x1, Y);
                    }
                    if (iter > 0) { /* адаптивный шаг считается если известны оба значения*/
                        if (((y1 / y2) > 2) || ((y2 / y1) >
                                                2)) { /* если коэфициент отношения между значениями слишком большой, то уменьшаем шаг*/
                            x1 += sh / 2;
                        } else {
                            if (((y1 / y2) < 0.5) || ((y2 / y1) <
                                                      0.5)) { /*если коэфициент отношения между значениями слишком маленький, то увеличиваем шаг */
                                x1 += sh * 2;
                                y1 = y2; /*делаем "сдвиг" значений, т.е. первому значению присваевается второе*/
                            } else x1 += sh; /*если изменять шаг не нужно, то прссто прибавляем к значению Х1 размер обычного шага*/
                            if (iter > 1) {
                                y1 = y2;/*делаем "сдвиг" значений, т.е. первому значению присваевается второе*/
                            }
                        }
                    }

                } else {
                    printf("X=%.3lf Y=%.3lf\n", x1, Y);
                    x1 += sh;
                } /* если адаптивный не срабатывает, т.е. не зачем увеличивать или уменьшать шаг, то просто прибавляем значение r*/
                iter += 1;
                /*printf("Количество шагов:%i\n", iter);*/
                iter = 2;
                continue;
            }
            break;

        default:
            /* printf("ne verno vvedena function \n");*/

    }
    /*printf("Вычислим еще раз? (1-да,2-нет) \n");*/
    scanf("%lf", &pr);
    if (pr == 1)
        goto nachalo;
    return 0;
}
